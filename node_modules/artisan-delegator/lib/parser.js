var escape = require('./utilities').escape
  , merge = require('./utilities').merge
  , ParserError = require('./errors').ParserError
  , defaultPatterns =
    { word:     '\\w+'
    , alpha:    '[a-zA-Z]+'
    , digits:   '\\d+'
    , number:   '\\d*\\.?\\d+'
    , chunk:    '[^/\\.]+'
    , segment:  '[^/]+'
    , any:      '.+'
    }
  ;

function SimpleParser(patterns) {
  this._patterns = merge(defaultPatterns, patterns || {});
}

SimpleParser.prototype.defaultPattern = 'chunk';

SimpleParser.prototype.patternStart = '{';

SimpleParser.prototype.patternEnd = '}';

SimpleParser.prototype.optionalStart = '[';

SimpleParser.prototype.optionalEnd = ']';

SimpleParser.prototype.parse = function (path) {
  var keys = []
    , position = 0
    , patterns = this._patterns
    , patternStart = this.patternStart
    , patternEnd = this.patternEnd
    , optionalStart = this.optionalStart
    , optionalEnd = this.optionalEnd
    , defaultPattern = this.defaultPattern
    , regexp = new RegExp('[' + escape(patternStart + patternEnd) + ']')
    ;

  function _split(path) {
    var parts = []
      , a = path.indexOf(optionalStart)
      , b = path.indexOf(optionalEnd)
      , level = 0
      , i = 0
      , j = 0
      ;

    while (-1 !== a || -1 !== b) {
      i = (-1 === a) ? b : (-1 === b) ? a : Math.min(a, b);

      if (']' === path[i]) {
        level -= 1;
      }

      if (0 === level) {
        parts.push(path.substring(j, i));
        j = i + 1;
      }

      if ('[' === path[i]) {
        level += 1;
      }

      a = path.indexOf(optionalStart, i + 1);
      b = path.indexOf(optionalEnd, i + 1);
    }

    if (0 !== level) {
      throw new ParserError('Unbalanced optional delimiters.');
    }

    parts.push(path.substring(j, path.length));

    return parts;
  }

  function _parse(path) {
    var parts = []
      ;

    if (0 <= path.indexOf(optionalStart) || 0 <= path.indexOf(optionalEnd)) {
      parts = _split(path);
      parts = parts.map(_parse, this);

      parts = parts.map(function (value, index) {
        if (1 === index % 2) {
          return '(?:' + value + ')?';
        }
        return value;
      });
    }
    else {
      parts = path.split(regexp).map(function (value, index) {
        var parts
          , name
          , pattern
          ;

        if (1 === index % 2) {
          parts = value.split(':');
          name = parts[0];
          pattern = parts[1] || defaultPattern;

          if (undefined === patterns[pattern]) {
            throw new ParserError('Pattern "' + pattern + '" not found.');
          }

          keys.push(parts[0] || position++);
          return '(' + patterns[pattern] + ')';
        }
        return escape(value);
      }, this);

    }

    return parts.join('');
  }

  return { expr: new RegExp('^' + _parse(path) + '$'), keys: keys };
};

exports.SimpleParser = SimpleParser;