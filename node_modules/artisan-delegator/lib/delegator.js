var parser = require('./parser')
  , errors = require('./errors')
  , utilities = require('./utilities')
  , path = require('path')
  , fs = require('fs')
  , url = require('url')
  ;

function Match(params, callback) {
  this.params = params;
  this.callback = callback;
}

function Mapping(expr, keys, callbacks) {
  this.expr = expr;
  this.keys = keys;
  this.callbacks = callbacks;
}

Mapping.prototype.match = function (path) {
  var match = this.expr.exec(path)
    , length
    , params = {}
    , i
    ;

  if (!match) {
    return null;
  }

  for (i = 1, length = match.length; i < length; ++i) {
    params[this.keys[i - 1]] = match[i];
  }

  return params;
};

function Delegator(options) {
  options = options || {};

  this.parser = options.parser || new parser.SimpleParser();
  this.prefix = options.prefix || '';
  this.wrap = options.wrap;
  this.length = 0;

  if (options.mappings) {
    this.batch(options.mappings);
  }

  if (options.filename) {
    this.load(options.filename);
  }

  this.middleware = this.middleware.bind(this);
}

Delegator.prototype.add = function (path, callbacks, options) {
  options = options || {};

  var prefix = (undefined !== options.prefix) ? options.prefix : this.prefix
    , parser = (undefined !== options.parser) ? options.parser : this.parser
    , wrap = (undefined !== options.wrap) ? options.wrap : this.wrap
    , compiled = parser.parse(prefix + path)
    , mapping
    , key
    ;

  callbacks = utilities.merge({}, callbacks);

  if (wrap) {
    for (key in callbacks) {
      if (callbacks.hasOwnProperty(key)) {
        callbacks[key] = wrap(callbacks[key]);
      }
    }
  }

  mapping = new Mapping(compiled.expr, compiled.keys, callbacks);

  this[this.length] = mapping;

  this.length++;

  return mapping;
};

Delegator.prototype.match = function (path, method) {
  var exists = false
    , callbacks
    , params
    , i
    ;

  for (i = this.length - 1; i >= 0; --i) {
    params = this[i].match(path);

    if (params) {
      exists = true;

      callbacks = this[i].callbacks;

      if (callbacks[method] || callbacks['*']) {
        return new Match(params, callbacks[method] || callbacks['*']);
      }
    }
  }

  if (exists) {
    throw new errors.MethodNotAllowedError();
  }

  throw new errors.NotFoundError();
};

Delegator.prototype.batch = function (mappings, options) {
  var length = mappings.length
    , i
    ;

  for (i = 0; i < length; ++i) {
    this.add(mappings[i][0], mappings[i][1], options);
  }
};

Delegator.prototype.load = function (filename, options) {
  var lines = fs.readFileSync(filename, 'utf8').split('\n')
    , line
    , callbacks = {}
    , dirname = path.dirname(filename)
    , expr
    , parts
    ;

  function resolve(callback) {
    var parts = callback.split(':')
      , message
      , result
      , filename = path.resolve(dirname, parts.shift())
      , name
      ;

    result = require(filename);

    if (0 !== parts.length) {
      name = parts.shift();
      result = result[name];

      if (undefined === result) {
        callback = filename + ':' + name;
        message = 'Cannot find callback \'' + callback + '\'.';
        throw new errors.MappingFileError(message);
      }
    }

    return result;
  }

  while (lines.length) {
    line = lines.shift().split('#')[0];

    if ('' === line.trim()) {
      continue;
    }

    if (' ' === line[0]) {
      if (undefined === expr) {
        throw new errors.MappingFileError('Missing path expression.');
      }

      parts = line.trim().split(/\s+/);

      if (2 > parts.length) {
        throw new errors.MappingFileError('Missing callback.');
      }

      callbacks[parts.shift()] = resolve(parts.shift());
    }
    else {
      if (undefined !== expr && 0 === Object.keys(callbacks).length) {
        throw new errors.MappingFileError('Missing callback.');
      }

      if (undefined !== expr) {
        this.add(expr.trim(), callbacks, options);
      }

      callbacks = {};
      expr = line;
    }
  }

  if (undefined !== expr) {
    this.add(expr, callbacks, options);
  }
};

Delegator.prototype.middleware = function (req, res, next) {
  var pathname = url.parse(req.url).pathname
    , match
    ;

  try {
    match = this.match(pathname, req.method);
  }
  catch (e) {
    if (e instanceof errors.NotFoundError) {
      return next();
    }

    return next(e);
  }

  req.params = match.params;

  match.callback(req, res, next);
};

function factory(options) {
  var delegator = new exports.Delegator(options);

  return delegator.middleware;
}

module.exports = exports = factory;

exports.parser = require('./parser');
exports.errors = require('./errors');
exports.utilities = require('./utilities');

exports.Delegator = Delegator;
exports.Match = Match;
exports.Mapping = Mapping;